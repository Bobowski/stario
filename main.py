import asyncio

from stario import Stario
from stario.datastar import Signal
from stario.html import button, div, h1, input_, p
from stario.toys import toy_page

app = Stario()


# 1. Query: Return a full HTML page
@app.query("/")
async def homepage():
    """A query returns data (in this case, HTML)"""
    return toy_page(
        h1("Welcome to Stario"),
        p("Explore three core concepts below:"),
        # Static section
        div(
            h1("1. Query Routes (Read)"),
            p("This entire page was generated by a @query route - it returns data"),
        ),
        # Interactive section for command
        div(
            h1("2. Command Routes (Write)"),
            input_(
                {"data-bind": "name"},
                {
                    "id": "name",
                    "type": "text",
                    "placeholder": "Enter your name...",
                },
            ),
            button(
                {"data-on:click": "@post('/greet')"},
                "Greet Me",
            ),
            div({"id": "greet"}),  # Updates appear here
        ),
        # Streaming section
        div(
            h1("3. Streaming Responses (Real-time)"),
            button(
                {"data-on:click": "@get('/counter')"},
                "Start Counter",
            ),
            div({"id": "counter"}),  # Updates stream here
        ),
    )


# 2. Command: Update a specific part of the page
@app.command("/greet")
async def greet(name: Signal[str]):
    """A command changes state. Here we return HTML to replace a div."""
    return div({"id": "greet"}, f"Hello, {name}! 👋")


# 3. Query that streams: Yield HTML updates over time
@app.query("/counter")
async def counter():
    """
    Streaming responses are just generator functions!

    Instead of returning once, you yield multiple times.
    Each yield sends a live update to the browser via Server-Sent Events.
    Datastar (our frontend library) applies each update automatically.
    """
    interval = 0.01
    elapsed = 0
    while elapsed < 30:
        # Each yield updates the counter div in real-time
        yield div(
            {"id": "counter"},
            f"⏱️ Counter: {elapsed:.2f} seconds",
        )
        await asyncio.sleep(interval)
        elapsed += interval
